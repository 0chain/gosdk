<!DOCTYPE html>

<head>
  <!-- for zcn.wasm-->
  <script src="https://cdn.jsdelivr.net/gh/herumi/bls-wasm@v1.0.0/browser/bls.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/golang/go@go1.18.5/misc/wasm/wasm_exec.js"></script>
  <script src="zcn.js"></script>


  <!-- for demo -->
  <script src="dom.js"></script>

  <!-- for player.js -->
  <script src="https://cdn.jsdelivr.net/npm/mux.js@6.3.0/dist/mux.js"></script>
  <script src="EBML.js"></script>
  <script src="player.js"></script>

</head>

<body>

  <h2>please download zcn.wasm from https://github.com/0chain/gosdk/releases/latest first</h2>

  <fieldset>
    <legend>logging</legend>
    <span>
      <button id="btnShowLogs">Show</button>
      <button id="btnHideLogs">Hide</button>
    </span>
    <br>
    <textarea id="logs" rows="10" cols="100">

  </textarea>
  </fieldset>

  <fieldset>
    <legend>Wallet</legend>
    <label for="clientId"> ClientID </label> <input id="clientId" name="clientId" style="width: 600px;"
      value="8e91766de0c988487bf4596fd86642b1b0325ef086d5af6327d7d9de69f2f1db" /><br>
    <label for="privateKey">PrivateKey</label> <input id="privateKey" name="privateKey" style="width: 600px;"
      value="2009c7de6d9154c5253b21ad04b04e3cc4fe9f133de6936409f6abd95f82520c" /><br>
    <label for="publicKey"> PublicKey</label> <input id="publicKey" name="publicKey" style="width: 600px;"
      value="9759c52aca48ef15f88d606fecfacb45d7d1c95a49286ba6ffa859dd010ef116892a0c2f7c40ff48543fc2082f82838b1f86cf8b7be6f5d81f81730a51e775a2" /><br>
    <label for="mnemonic"> Mnemonic</label> <input id="mnemonic" name="mnemonic" style="width: 600px;"
      value="gauge rigid typical memory buzz rule reunion field imitate bubble cushion gun brain script drum program sudden update interest poet crouch neutral smart very" /><br>




    <button id="btnSetWallet">Change Wallet</button>
    <button id="btnSendMeTokens">Send Me Tokens</button>
    <button id="btnGetBalance">Get Balance</button>

    <button id="btnGetUSDRate">Get USD Rate</button>
  </fieldset>

  <fieldset>
    <legend>Sharing</legend>
    <label for="authTicket"> AuthTicket </label> <input id="authTicket" name="authTicket" style="width: 600px;"
      value="eyJjbGllbnRfaWQiOiJhNGM1M2JmMjQ4YzYzNGVhNDgzYTk4Y2JhYTZiNzY3MjI2ZjUwNDUwNmIyOTkzODRiMzBmMmMwMGE1MmYwODUxIiwib3duZXJfaWQiOiIzMDc2NGJjYmE3MzIxNmI2N2MzNmIwNWExN2I0ZGQwNzZiZmRjNWJiMGVkODQ4NTZmMjc2MjIxODhjMzc3MjY5IiwiYWxsb2NhdGlvbl9pZCI6IjJmMjc3NDJlODYxN2YyY2U1MTk2OWFhNWQ1ZDAyY2MyZDg1NzQ1MzQ5MGVkZjBlODYzNmE0OTdjYjRmNTY3MWUiLCJmaWxlX3BhdGhfaGFzaCI6IjVhYTE2NzkyZDQ1YWMwMzI0ZTExZjc0Y2E5N2M0NDk3Zjc2ZmIxM2ZkN2ExMjIzMjc4NzQ4ZjY4OGIyNzU2OGUiLCJhY3R1YWxfZmlsZV9oYXNoIjoiYjQxZTFmZGI2YThlNzM0MmNkMzk5ZjY3MWFiYWRkM2MyN2QzZDQ0YjdmZGM0OGU3Mzc1ZTI4ZTM3MTI2NWY3YiIsImZpbGVfbmFtZSI6InJ0eDA5MDIwMDIxMnAucGRmIiwicmVmZXJlbmNlX3R5cGUiOiJmIiwiZXhwaXJhdGlvbiI6MTY4ODY4OTcyMTcxNCwidGltZXN0YW1wIjoxNjg3MDAyNzE2LCJlbmNyeXB0ZWQiOnRydWUsInNpZ25hdHVyZSI6IjIyOWUyY2FkNTU5YzEwMGU4MTVhNjk2ZTQ5YTU3ZTUyNGU5ZmQ1YmZmZTRjYjAyY2I0MDM1NGY0OTQ1YzY5MWYifQ==" /><br>
    <button id="decodeAuthticket">DecodeAuthTicket</button>
  </fieldset>

  <fieldset>
    <legend>Allocations</legend>

    <span>
      <button id="btnListAllocations">List</button>
      <button id="btnCreateAllocation">Create</button>
      <button id="btnGetAllocation">Get</button>
      <button id="btnCreateFreeAlloc">CreateFreeallocation</button>
      <button id="btnGetAllocationMinLock">AllocationMinLock</button>
      <button id="btnGetUpdateAllocationMinLock">UpdateAllocationMinLock</button>
      <button id="btnRemoteFileMap">RemoteFileMap</button>
      <button id="btnAddReplaceBlobber">AddReplaceBlobber</button>
    </span>

    <br>

    <div id="listAllocations">
    </div>

  </fieldset>

  <fieldset>
    <legend>Blobbers</legend>

    <span>
      <button id="btnListBlobbers">List</button>
      <button id="btnListBlobberSettings">Get</button>
      <button id="updateBlobberSettings">Update</button>
    </span>

    <br>

    <div id="listBlobbers">
    </div>

  </fieldset>

  <fieldset>
    <legend>Files</legend>
    <button id="btnListFiles">List</button>
    <span><input id="inputSelectedFile" type="file" multiple /> <button id="btnUploadFile">Upload</button> </span>
    <button id="btnUploadEncryptFile">EncryptedUpload</button> </span>
    [ <button id="btnDownloadFile">Download</button> | <button id="btnDownloadShared">Download with AuthTicket</button>
    | <button id="btnMultiDownload">MultiDownload</button>
    ]
    <button id="btnViewFile">View</button>
    <button id="btnGetFileStats">GetFileStats</button>
    <button id="btnDelete">Delete</button>
    <button id="btnShare">Share</button>
    <button id="btnGetContainers">getcontainers</button>
    <button id="btnUpdateContainer">updatecontainer</button>
    <button id="btnSearchContainer">searchcontainer</button>
    <button id="btnAllocationRepair">Repair</button>
    <button id="btnMultiOps">MultiOperation</button>
    <button id="createDir">createDir</button>
    <button id="btnGetAllocationDiff">getAllocationDiff</button>

    <br>

    <div id="listFiles">
    </div>

  </fieldset>


  <fieldset>
    <legend>Output</legend>
    <pre id="txtOutput" style="font-size: 20px; font-weight: bold;">
    </pre>
  </fieldset>


  <fieldset>
    <legend>Media WebPlayer</legend>

    <div id="container">
      <video id='player' preload="metadata" controls></video>
    </div>
    <div className="controls">
      [ <button id="btnPlay">Play</button> | <button id="btnPlayShared">Play with auth ticket</button> ]
      <button id="btnPause">Pause</button>
      <button id="btnStop">Stop</button>
    </div>
  </fieldset>


  <fieldset>
    <legend>Image Viewer</legend>
    <img id="viewer" src="image.png" width="600" />
  </fieldset>

  <script>

    window.downloadCallback = function (totalBytes, completedBytes, error) {
      console.log("download: " + completedBytes + "/" + totalBytes + " err:" + error)
    }

    const getWallet = () => {
      const clientID = get('clientId').value
      const publicKey = get('publicKey').value
      const privateKey = get('privateKey').value
      const mnemonic = get('mnemonic').value
      return {
        clientID, publicKey, privateKey, mnemonic
      }
    }

    // get active blobbers from network
    async function getBlobbersFromNetwork() {
      const GET_BLOBBERS = `/v1/screst/6dba10422e368813802877a85039d3985d96760ed844092319743fb3a76712d7/getblobbers`
      const randomsharder = " https://dev1.zus.network/sharder01" // todo: get this randomly from network
      url = randomsharder + GET_BLOBBERS
      let response = await fetch(url);
      let data = await response.json();
      return data;
    }

    async function getBlobberDetails(blobberID) {
      const GET_BLOBBER = `/v1/screst/6dba10422e368813802877a85039d3985d96760ed844092319743fb3a76712d7/getBlobber?blobber_id=`
      const randomsharder = " https://dev1.zus.network/sharder01" // todo: get this randomly from network
      url = randomsharder + GET_BLOBBER + blobberID
      let response = await fetch(url);
      let data = await response.json();
      return data;
    }

    const networkConfig = {
      chainId: '0afc093ffb509f059c55478bc1a60351cef7b4e9c008a53a6cc8241ca8617dfe',
      signatureScheme: 'bls0chain',
      minConfirmation: 50,
      minSubmit: 50,
      confirmationChainLength: 3,
    }

    const query = new URLSearchParams(window.location.search);

    let network = query.get('network')
    if (!network || network == 'undefined') {
      network = "dev.zus.network"
    }

    const blockWorker = 'https://' + network + '/dns';
    const config = [
      networkConfig.chainId,
      blockWorker,
      networkConfig.signatureScheme,
      networkConfig.minConfirmation,
      networkConfig.minSubmit,
      networkConfig.confirmationChainLength,
      'https://0box.' + network, //zboxHost
      'vult', //zboxAppType
      3,
    ]

    const bls = window.bls
    let goWasm;
    createWasm().then(async wasm => {
      await wasm.sdk.init(...config)
      await bls.init(bls.BN254)
      const { clientID, privateKey, publicKey, mnemonic } = getWallet()
      await wasm.setWallet(bls, clientID, privateKey, publicKey, mnemonic)

      goWasm = wasm
    })

    onClick('btnSetWallet', async () => {
      const { clientID, privateKey, publicKey, mnemonic } = getWallet()
      await goWasm.setWallet(bls, clientID, privateKey, publicKey, mnemonic)
    })


    onClick('btnSendMeTokens', async () => {
      await goWasm.sdk.faucet("pour", JSON.stringify("{Pay day}"), 10)
    })

    onClick('btnGetBalance', async () => {
      const { clientID } = getWallet()
      const wallet = await goWasm.sdk.getWalletBalance(clientID)
      txtOutput.innerHTML = JSON.stringify(wallet, null, 2)
    })

    onClick('btnCreateFreeAlloc', async () => {
      var token = prompt("freeallocation token: ");
      try {
        const alloc = await goWasm.sdk.createfreeallocation(token)
        console.log("create freeallocation with ID: ", alloc)
      } catch(e) {
        alert(e)
      }
    })

    let allocations = []
    let blobbers = []
    let files = []

    const bindAllocations = () => setHtml("listAllocations", allocations.map(a => `<input type="radio"  name="selectedAllocation" value="${a.id}"><label for="${a.id}">${a.id}</label><br>`).join(""))
    const getSelectedAllocation = () => [...document.getElementsByName('selectedAllocation')].filter(it => it.checked).map(it => it.value).find(it => it != "");

    const bindFiles = () => setHtml('listFiles', files.map(f => `<input type="radio" name="selectedFile" value="${f.path}"><label for="${f.path}">[${f.type}]${f.path}</label><br>`).join(""))
    const getSelectedFile = () => [...document.getElementsByName('selectedFile')].filter(it => it.checked).map(it => it.value).find(it => it != "");

    const bindBlobbers = () => setHtml("listBlobbers", blobbers.map(a => `<input type="radio"  name="selectedBlobbers" value="${a.id}"><label for="${a.id}">${a.id}</label><br>`).join(""))
    const getSelectedBlobbers = () => [...document.getElementsByName('selectedBlobbers')].filter(it => it.checked).map(it => it.value).find(it => it != "");

    onClick('btnCreateAllocation', async () => {

      const expiry = new Date()
      expiry.setDate(expiry.getDate() + 300)

      //name string, datashards, parityshards int, size, expiry int64,minReadPrice, maxReadPrice, minWritePrice, maxWritePrice int64, lock int64,preferredBlobberIds []string
      const config = {
        datashards: 2,
        parityshards: 2,
        size: 2 * 1073741824,
        minReadPrice: 0,
        maxReadPrice: 184467440737095516,
        minWritePrice: 0,
        maxWritePrice: 184467440737095516,
        lock: 18800000000
      }
      try {
        const allocation = await goWasm.sdk.createAllocation(config.datashards, config.parityshards, config.size, config.minReadPrice, config.maxReadPrice, config.minWritePrice, config.maxWritePrice,
          config.lock, [])

        console.log(allocation)
        allocations = await goWasm.sdk.listAllocations()
        bindAllocations()
      } catch (e) {
        alert(e)
      }

    })

    onClick('btnListAllocations', async () => {
      allocations = await goWasm.sdk.listAllocations()
      bindAllocations()
    })

    onClick('btnRemoteFileMap', async () => {
      const allocationID = getSelectedAllocation()
      if (!allocationID) {
        alert("please select allocation")
        return
      }
      try {
        let resp = await goWasm.sdk.getRemoteFileMap(allocationID)
        console.log(resp)
        txtOutput.innerHTML = JSON.stringify(resp, null, 2)
      } catch (e) {
        alert(e)
      }
    })

    onClick('createDir', async () => {
      const allocationId = getSelectedAllocation()
      goWasm.sdk.createDir(allocationId, "/dir2")
    })

    onClick('btnListBlobbers', async () => {
      // list active blobbers
      let blobbersResp = await getBlobbersFromNetwork()
      blobbers = blobbersResp.Nodes
      bindBlobbers()
    })

    onClick('btnGetAllocation', async () => {
      const allocationId = getSelectedAllocation()
      if (!allocationId) {
        alert("please select allocation")
        return
      }
      const alloc = await goWasm.sdk.getAllocation(allocationId)
      txtOutput.innerHTML = JSON.stringify(alloc, null, 2)
    })

    onClick('btnGetAllocationMinLock', async () => {
      let dataShards = 2
      let parityShards = 2
      let size = 100000
      let maxReadPrice = 10000000000
      let maxWritePrice = 1000000000
      try {
        const price = await goWasm.sdk.getAllocationMinLock(dataShards, parityShards, size, maxReadPrice, maxWritePrice)
        txtOutput.innerHTML = price
      } catch (e) {
        alert(e)
      }
    })

	onClick('btnGetUpdateAllocationMinLock', async () => {
		let size = 100000
		const allocationId = getSelectedAllocation()
		if (!allocationId) {
			alert("please selection allocationID")
			return
		} else {
			console.log("allocation:", allocationId)
		}
		try {
			const price = await goWasm.sdk.getUpdateAllocationMinLock(allocationId, size, true, false, "", "")
			txtOutput.innerHTML = price
		} catch (e) {
			alert(e)
		}
	})

    onClick('btnListBlobberSettings', async () => {
      const blobberID = getSelectedBlobbers()
      if (!blobberID) {
        alert("please select blobber")
        return
      }
      const details = await getBlobberDetails(blobberID)
      txtOutput.innerHTML = JSON.stringify(details, null, 2)
    })

    // increases readprice of blobber by 1 unit
    onClick('updateBlobberSettings', async () => {
      const blobberID = getSelectedBlobbers()
      if (!blobberID) {
        alert("please select blobber")
        return
      }
      let details = await getBlobberDetails(blobberID)
      details.terms.read_price += 1
      try {
        const txn = await goWasm.sdk.updateBlobberSettings(JSON.stringify(details))
      } catch (e) {
        alert(e)
      }
      // txtOutput.innerHTML = JSON.stringify(alloc, null, 2)
    })

    onClick('btnListFiles', async () => {
      const allocationId = getSelectedAllocation()
      if (!allocationId) {
        alert("please selection allocationID")
        return
      }
      const { list = [] } = await goWasm.sdk.listObjects(allocationId, '/')
      files = list || []
      bindFiles()
    })

    onClick('btnUploadFile', async () => {
      const { files } = get('inputSelectedFile')
      if (files && files.length > 0) {

        const objects = []
        const allocationId = getSelectedAllocation()
        for (const file of files) {
          objects.push({
            allocationId: allocationId,
            remotePath: `/${file.name}`,
            file: file,
            thumbnailBytes: await readBytes(file),//only for demo, don't upload original file as thumbnail in production
            encrypt: false,
            webstreaming: false,
            isUpdate: false,
            isRepair: false,
            numBlocks: 100,
            callback: function (totalBytes, completedBytes, error) {
              console.log(file.name + " " + completedBytes + "/" + totalBytes + " err:" + error)
            }
          })
        }
        const results = await goWasm.bulkUpload(objects)
        console.log(JSON.stringify(results))
      }
    })

    onClick('btnShare', async () => {
      // change these values according to your wallet (obtained from zbox `zbox getwallet`)
      let clientID = "a4c53bf248c634ea483a98cbaa6b767226f504506b299384b30f2c00a52f0851"
      let encryptionPublicKey = "SCxZlinUp+Z29jt8hXT623osEjALXVel6HdHgq1lXEY="

      const file = files.find(it => it.path == getSelectedFile())
      if (file) {
        const allocationId = getSelectedAllocation()
        if (!allocationId) {
          alert("please provide allocationId")
          return
        }

        console.log("sharing file", file?.path)
        let time = Date.now()
        let expiration = time += 3600 // after 1 hour
        let availableAfter = 0
        try {
          const result = await goWasm.sdk.share(allocationId, file?.path, "", "", expiration, false, availableAfter)
          console.log("output of share", result)
          txtOutput.innerHTML = JSON.stringify(result, null, 2)
        } catch (e) {
          alert(e)
        }
      }

    })

    onClick('btnUploadEncryptFile', async () => {
      const { files } = get('inputSelectedFile')
      if (files && files.length > 0) {

        const objects = []
        const allocationId = getSelectedAllocation()
        if (!allocationId) {
          alert("please provide allocationId")
        }
        for (const file of files) {
          objects.push({
            allocationId: allocationId,
            remotePath: `/${file.name}`,
            file: file,
            thumbnailBytes: await readBytes(file),//only for demo, don't upload original file as thumbnail in production
            encrypt: true,
            webstreaming: false,
            isUpdate: false,
            isRepair: false,
            numBlocks: 100,
            callback: function (totalBytes, completedBytes, error) {
              console.log(file.name + " " + completedBytes + "/" + totalBytes + " err:" + error)
            }
          })
        }

        const results = await goWasm.bulkUpload(objects)

        console.log(JSON.stringify(results))
      }
    })

    onClick('btnDownloadFile', async () => {
      const path = getSelectedFile()
      if (path) {

        const allocationId = getSelectedAllocation()

        //allocationID, remotePath, authTicket, lookupHash string, downloadThumbnailOnly bool, numBlocks int
        const file = await goWasm.sdk.download(allocationId, path, '', '', false, 10, "downloadCallback", true)

        const a = document.createElement('a')
        document.body.appendChild(a)
        a.style = 'display: none'

        a.href = file.url
        a.download = file.fileName
        a.click()
        window.URL.revokeObjectURL(file.url)
        document.body.removeChild(a)

      }
    })

    onClick('btnAddReplaceBlobber', async () => {

      var addremoveBlobberIDs = prompt("Add Blobber ID and remove blobberID (separated by a comma): ");

      var [addBlobberId, removeBlobberID] = addremoveBlobberIDs.split(",");
      // removeBlobberID = removeBlobberID !== undefined ? value : "";

      console.log("addBlobberId", addBlobberId)
      console.log("removeBlobberID", removeBlobberID)
      // addBlobberId = addBlobberId.trim()
      // removeBlobberID = removeBlobberID.trim()
      const allocationId = getSelectedAllocation()
      if (!allocationId) {
        alert("please provide allocationId")
      }

      try {
        const file = await goWasm.sdk.updateAllocationWithRepair(allocationId, 0, 0, 5000000000, false, addBlobberId, removeBlobberID)

      } catch (e) {
        alert(e)
      }
    })

    onClick('btnDownloadShared', async () => {

      const authTicket = get('authTicket').value
      if (authTicket) {
        try {
          const file = await goWasm.sdk.download('', '', authTicket, '', false, 10, "downloadCallback", true)

          console.log("downloaded file", file)
          const a = document.createElement('a')
          document.body.appendChild(a)
          a.style = 'display: none'
          a.href = file.url
          a.download = file.fileName
          a.click()
          window.URL.revokeObjectURL(file.url)
          document.body.removeChild(a)
        } catch (e) {
          alert(e)
        }
      }
    })

    onClick('decodeAuthticket', async () => {
      const authTicket = get('authTicket').value
      if (authTicket) {
        try {
          const output = await goWasm.sdk.decodeAuthTicket(authTicket);
          console.log(output)
          txtOutput.innerHTML = JSON.stringify(output, null, 2)
        } catch (e) {
          alert(e)
        }
      }
    })

    onClick('btnViewFile', async () => {
      const file = files.find(it => it.path == getSelectedFile())
      if (file && file.mimetype.startsWith('image')) {
        const allocationId = getSelectedAllocation()
        const { url } = await goWasm.sdk.download(allocationId, file.path, '', '', false, 10,)
        get('viewer').setAttribute('src', url)
      }
    })

    const player = get('player')
    let isPlayerReady = false

    onClick('btnPlay', async () => {

      if (isPlayerReady) {
        if (player.paused) {
          player.play()
        }
      } else {

        const file = files.find(it => it.path == getSelectedFile())

        const isLive = file.type == 'd'

        if (file) {
          const allocationId = getSelectedAllocation()
          startPlay({
            goWasm,
            allocationId,
            containerElement: get('container'),
            videoElement: player,
            remotePath: file?.path,
            authTicket: '',
            lookupHash: file?.lookup_hash,
            mimeType: file?.mimetype,
            isLive: isLive,
          })
          isPlayerReady = true
        }
      }

    })

    onClick('btnPlayShared', async () => {

      if (isPlayerReady) {
        if (player.paused) {
          player.play()
        }
      } else {

        const authTicket = get('authTicket').value

        const isLive = false

        if (authTicket) {
          const allocationId = getSelectedAllocation()
          startPlay({
            goWasm,
            allocationId,
            videoElement: player,
            remotePath: '',
            authTicket: authTicket,
            lookupHash: '',
            mimeType: '',
            isLive: isLive,
          })
          isPlayerReady = true
        }
      }

    })

    onClick('btnPause', async () => {
      player.pause();
    })

    onClick('btnStop', async () => {
      if (isPlayerReady) {
        stopPlay({ goWasm, videoElement: player })
        isPlayerReady = false
      }
    })


    const log = console.log
    const logs = get('logs')
    onClick('btnShowLogs', async () => {
      await goWasm.sdk.showLogs()
      console.log = s => {
        log(s)
        logs.value += s + "\n"
        logs.scrollLeft = 0;
        logs.scrollTop = logs.scrollHeight;
      }
    })

    onClick('btnHideLogs', async () => {
      await goWasm.sdk.hideLogs()
      console.log = log
    })



    onClick('btnGetFileStats', async () => {
      const file = files.find(it => it.path == getSelectedFile())
      if (file) {
        const allocationId = getSelectedAllocation()
        const stats = await goWasm.sdk.getFileStats(allocationId, file?.path)
        txtOutput.innerHTML = JSON.stringify(stats, null, 2)
      }

    })

    onClick('btnDelete', async () => {
      const file = files.find(it => it.path == getSelectedFile())
      if (file) {
        const allocationId = getSelectedAllocation()
        await goWasm.sdk.delete(allocationId, file?.path)
      }
    })

    onClick('btnGetUSDRate', async () => {

      const rate = await goWasm.sdk.getUSDRate("zcn")
      txtOutput.innerHTML = rate
    })

    onClick('btnGetContainers', async () => {
      const domain = "https://chimneyhwayr.zus.network"
      const username = "username1"
      const password = "password1"

      try {
        const stats = await goWasm.sdk.getcontainers(username, password, domain)
        txtOutput.innerHTML = JSON.stringify(stats, null, 2)
      } catch (e) {
        alert(e)
      }
    })

    onClick('btnUpdateContainer', async () => {
      const containerid = "3f9b21fcb9df9d6cc88b024357bf940284f749d4c30e13b7791d721def752498"
      const domain = "https://chimneyhwayr.zus.network"
      const username = "username1"
      const password = "password1"
      const image = "0chaindev/blobber:staging"
      try {
        const stats = await goWasm.sdk.updatecontainer(username, password, domain, containerid, image)
        txtOutput.innerHTML = JSON.stringify(stats, null, 2)
      } catch (e) {
        alert(e)
      }
    })

    onClick('btnSearchContainer', async () => {
      const domain = "https://chimneyhwayr.zus.network"
      const username = "username1"
      const password = "password1"
      const containername = "validator"
      try {
        const stats = await goWasm.sdk.searchcontainer(username, password, domain, containername)
        txtOutput.innerHTML = JSON.stringify(stats, null, 2)
      } catch (e) {
        alert(e)
      }
    })

    onClick('btnAllocationRepair', async () => {
      const allocationId = getSelectedAllocation()
      const output = await goWasm.sdk.allocationRepair(allocationId, "/")
      txtOutput.innerHTML = output
    })

    onClick('btnMultiDownload', async () => {
      console.log('multidownload')
      const path = getSelectedFile()

      const objects = []
      const allocationId = getSelectedAllocation()
      if (!allocationId) {
        alert("please provide allocationId")
      }

      objects.push({
        remotePath: path,
        downloadOp: 1,
        numBlocks: 0,
      })
      let stringifiedArray = JSON.stringify(objects);

      try {
        const results = await goWasm.sdk.multiDownload(allocationId, stringifiedArray, '', '')
        console.log(JSON.stringify(results))
      } catch (e) {
        alert(e)
      }

    })

    onClick('btnMultiOps', async () => {
      const allocationId = getSelectedAllocation()
      if (!allocationId) {
        alert("please provide allocationId")
      }
      const objects = []

      objects.push({
        operationType: `move`,
        remotePath: `/zcn.wasm`,
        destPath: `/folder1`,
      })

      let stringifiedArray = JSON.stringify(objects);

      try {
        console.log("executing", objects[0])
        const output = await goWasm.sdk.multiOperation(allocationId, stringifiedArray)
      } catch (e) {
        alert(e)
      }
    })

    onClick('btnGetAllocationDiff', async() => {
      const allocationId = getSelectedAllocation()
      if (!allocationId) {
        alert("please provide allocationId")
      }

      const objects = []
      objects.push({
        allocationId: allocationId,
        localRootPath: `/tmp`,
      })

      let stringifiedArray = JSON.stringify(objects);

      try {
        console.log("executing getAllocationDiff")
        const output = await goWasm.sdk.getAllocationDiff(allocationId, stringifiedArray)
        console.log(output)
      } catch (e) {
        alert(e)
      }

    })

  </script>
</body>
